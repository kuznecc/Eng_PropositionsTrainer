<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Preposition Trainer (React + PapaParse)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0f17; --fg:#e6ebf3; --muted:#aab6cf; --ok:#46d38a; --bad:#ff6b6b; --warning:#ff9800; --accent:#7aa2ff;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
    #root{height:100%;display:flex;align-items:center;justify-content:center;}
    .app{width:min(920px,100%);padding:24px 20px 32px;text-align:center;}
    .header{font:700 44px/1.2 Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; text-align:center; margin-top:16px;}
    .spacer-1{height:40px;}
    .spacer-2{height:60px;}
    .row{white-space:normal; scrollbar-width:thin;}
    .before,.after{font:500 28px/1.4 'Roboto Mono', monospace; display:inline;}
    .inputWrap{display:inline-flex; align-items:center; border:2px solid var(--accent); border-radius:10px; padding:6px 8px; margin:0 6px;}
    .input{font:600 20px/1 'Roboto Mono', monospace; color:var(--fg); background:transparent; border:none; outline:none; width:1ch; min-width:1ch;}
    .level{font:16px/1.5 Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:var(--muted); margin-bottom: 20px;}
    .level-selector { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
    .level-button { background-color: transparent; border: 2px solid var(--accent); color: var(--accent); padding: 8px 16px; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-size: 16px; font-weight: 500; }
    .level-button.selected { background-color: var(--accent); color: var(--bg); font-weight: 700; }
    .level-button:hover { background-color: rgba(122, 162, 255, 0.1); }
    .level-button.selected:hover { background-color: var(--accent); }
    .level-container { display: flex; flex-direction: column; align-items: center; }
    .level-indicator { font-weight: bold; color: var(--accent); margin-top: 2px; }
    .action-buttons { display: flex; justify-content: center; gap: 10px; margin-top: 20px; }
    .action-button { background-color: transparent; border: 2px solid var(--muted); color: var(--muted); padding: 8px 16px; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-size: 16px; font-weight: 500; }
    .action-button:hover { background-color: rgba(170, 182, 207, 0.1); }
    .button-container { display: flex; flex-direction: column; align-items: center; }
    .key-hint { font-family: 'Roboto Mono', monospace; font-size: 12px; color: var(--muted); margin-top: 4px; }
    .action-button.submit { border-color: var(--ok); color: var(--ok); }
    .action-button.submit:hover { background-color: rgba(70, 211, 138, 0.1); }
    .action-button.hint { border-color: #ffc700; color: #ffc700; }
    .action-button.hint:hover { background-color: rgba(255, 199, 0, 0.1); }
    .result{font:600 22px/1.4 Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin-bottom:6px;}
    .ok{color:var(--ok);} .bad{color:var(--bad);} .warning{color:var(--warning);}
    .hint-box { display: block; width: -moz-fit-content; width: fit-content; margin: 20px auto 0; border: 2px dotted #ffc700; border-radius: 8px; padding: 12px; text-align: left; background-color: rgba(255, 199, 0, 0.15); }
    .hint-box h4 { margin: 0 0 8px; color: var(--accent); text-align: center; }
    .debug-toggle { margin-top: 20px; display: flex; justify-content: center; align-items: center; gap: 8px; color: var(--muted); }
    .debug-toggle label { font-family: 'Roboto Mono', monospace; font-size: 12px; }
    .debug-box { display: block; width: -moz-fit-content; width: fit-content; margin: 20px auto 0; border: 2px dotted var(--muted); border-radius: 8px; padding: 12px; text-align: left; background-color: rgba(170, 182, 207, 0.1); }
    .debug-box h4 { margin: 0 0 8px; color: var(--muted); text-align: center; }
    .debug-box pre { margin: 0; font-family: 'Roboto Mono', monospace; font-size: 12px; }
    .tooltip-container { position: relative; display: inline-block; cursor: pointer; }
    .tooltip-text { visibility: hidden; width: 240px; background-color: #2a3140; color: var(--fg); text-align: left; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -120px; opacity: 0; transition: opacity 0.3s; white-space: pre-wrap; }
    .tooltip-container:hover .tooltip-text { visibility: visible; opacity: 1; }
    /* Simple 2s fade (no initial hold). Re-applying with a new key restarts it. */
    .fade2s{ animation: fade2s 2s linear forwards; }
    @keyframes fade2s{ 0% { opacity: 1; } 100% { opacity: 0; } }
    .sr-only{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const parse = (csv) => Papa.parse(csv.trim(), {header:true, skipEmptyLines:true}).data;
    const answersOf = (row) => (row.preposition||'').toLowerCase().split('|').map(s=>s.trim());

    // ===== Try to load external dataset.csv (same folder). If it exists, override fallback. =====
    async function loadDataset(){
      try {
        const res = await fetch('dataset.csv', { cache: 'no-store' });
        if (!res.ok) throw new Error('dataset.csv not found');
        const text = await res.text();
        const parsed = parse(text);
        if (Array.isArray(parsed) && parsed.length) return parsed;
        // if parsed but empty, fall back
      } catch (e) {
        // swallow and fall back
      }
      return parse(CSV_FALLBACK);
    }

    function App() {
      const [data, setData] = React.useState([]);
      const [levels, setLevels] = React.useState([]);
      const [selectedLevel, setSelectedLevel] = React.useState('All Levels');
      const [currentRow, setCurrentRow] = React.useState(null);
      const [value, setValue] = React.useState('');
      const inputRef = React.useRef(null);
      const [toast, setToast] = React.useState(null); // { key, type, text }
      const [showHint, setShowHint] = React.useState(false);
      const [showDebug, setShowDebug] = React.useState(false);
      const [solvedCount, setSolvedCount] = React.useState(0);
      const [preconditionTypes, setPreconditionTypes] = React.useState({});
      // Holds the last correctly submitted sentence parts for display
      const [prevAnswerParts, setPrevAnswerParts] = React.useState(null); // { before, preposition, after }

      React.useEffect(() => {
        let alive = true;
        (async () => {
          const rows = await loadDataset();
          if (!alive) return;
          setData(rows);
          const uniqueLevels = ['All Levels', ...new Set(rows.map(r => r.level).filter(Boolean))].sort((a, b) => {
            if (a === 'All Levels') return -1;
            if (b === 'All Levels') return 1;
            return a.localeCompare(b);
          });
          setLevels(uniqueLevels);
        })();
        return () => { alive = false; };
      }, []);

      React.useEffect(() => {
        let alive = true;
        async function loadPreconditionTypes() {
          try {
            const res = await fetch('assets/precondition_types.md');
            if (!res.ok) return;
            const text = await res.text();
            
            const types = {};
            const sections = text.split('## ').slice(1);
            sections.forEach(section => {
              const lines = section.split('\n').filter(line => line.trim() !== '');
              if (lines.length > 0) {
                const title = lines[0].replace(':', '').trim();
                const content = lines.slice(1).map(line => line.trim().replace(/^- /, '')).join('\n');
                types[title] = content;
              }
            });
            if (alive) {
              setPreconditionTypes(types);
            }
          } catch (e) {
            // ignore errors
          }
        }
        loadPreconditionTypes();
        return () => { alive = false; };
      }, []);

      const filteredData = React.useMemo(() => {
        if (selectedLevel === 'All Levels') return data;
        return data.filter(row => row.level === selectedLevel);
      }, [data, selectedLevel]);

      const pickRandomRow = React.useCallback(() => {
        setShowHint(false);
        if (!filteredData || filteredData.length === 0) {
          setCurrentRow(null);
          return;
        }
        const randomIndex = Math.floor(Math.random() * filteredData.length);
        setCurrentRow(filteredData[randomIndex]);
      }, [filteredData]);

      React.useEffect(() => {
        pickRandomRow();
      }, [pickRandomRow]);

      const check = React.useCallback(() => {
        if (!currentRow) return;
        if (toast?.type === 'warning') setToast(null);
        setShowHint(false);
        const correct = answersOf(currentRow);
        const v = (value || '').trim().toLowerCase();
        const wasOk = correct.includes(v);
        const toastData = {
          key: Date.now(),
          type: wasOk ? 'ok' : 'bad',
          text: wasOk ? 'OK' : 'Wrong'
        };
        setToast(toastData);
        if (wasOk) {
          setSolvedCount(c => c + 1);
          // Update previously submitted correct answer line
          const usage = currentRow?.['usage_case'] || currentRow?.['usage case'] || '';
          const [pb, pa] = usage.split('---');
          setPrevAnswerParts({
            before: (pb || '').trim(),
            preposition: (value || '').trim(),
            after: (pa || '').trim(),
          });
          pickRandomRow();
        } else {
          setValue('');
          focusInput();
        }
      }, [currentRow, value, pickRandomRow, toast]);

      React.useEffect(() => {
        if (!toast) return;
        const t = setTimeout(() => setToast(null), 2000);
        return () => clearTimeout(t);
      }, [toast]);
      
      const focusInput = () => setTimeout(()=> inputRef.current?.focus(), 0);
      React.useEffect(()=> {
        setValue('');
        focusInput();
      }, [currentRow]);

      const handleInputChange = (e) => {
        const newValue = e.target.value;
        const lastChar = newValue.slice(-1);

        if (/[a-zA-Z-]/.test(lastChar) || newValue === '') {
            if (toast?.type === 'warning') {
                setToast(null);
            }
        } else if (/\p{L}/u.test(lastChar)) {
            setToast({ key: Date.now(), type: 'warning', text: `Non-English layout. [${lastChar}]` });
        }
        
        setValue(newValue.replace(/[^a-zA-Z-]/g, ''));
      };

      const onSubmit = (e) => { e.preventDefault(); check(); };
      const inputWidthCh = Math.max(1, value.length);
      
      const [before, after] = (currentRow?.['usage_case'] || currentRow?.['usage case'] || '').split('---');

      React.useEffect(() => {
        const handleKeyDown = (event) => {
          // Allow typing in inputs, textareas, or content-editable elements without interference.
          const activeEl = document.activeElement;
          const isTypingInInput = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);

          if (event.key === 'Escape') {
            pickRandomRow();
            return;
          }
          if (event.key === '?') {
            setShowHint(prev => !prev);
            return;
          }

          // If a letter or hyphen is pressed and we are not already in an input, focus our main input.
          if ((/^[a-zA-Z-]$/.test(event.key) || event.key === 'Backspace') && !isTypingInInput) {
            inputRef.current?.focus();
          }
        };
        document.addEventListener('keydown', handleKeyDown);
        return () => {
          document.removeEventListener('keydown', handleKeyDown);
        };
      }, [pickRandomRow]);

      const footerContent = toast ? (
        <div key={toast.key} className="fade2s">
          <div className={`result ${toast.type}`}>{toast.text}</div>
        </div>
      ) : (
        <div style={{ visibility: 'hidden' }}>
          <div className="result">&nbsp;</div>
        </div>
      );

      const datasetStats = React.useMemo(() => {
        if (!data || data.length === 0) {
          return 'Dataset size: 0';
        }

        const levelCounts = data.reduce((acc, row) => {
          const level = row.level || 'Unknown';
          acc[level] = (acc[level] || 0) + 1;
          return acc;
        }, {});

        const levelCountsString = Object.entries(levelCounts)
          .sort(([levelA], [levelB]) => levelA.localeCompare(levelB))
          .map(([level, count]) => `${level}:${count}`)
          .join(', ');

        return `Dataset size: ${data.length} [${levelCountsString}]`;
      }, [data]);

      return (
        <div className="app">
          <div className="header">Preposition Trainer</div>
          <div className="spacer-1"/>
          <div className="level-selector">
            {levels.map(level => (
              <div key={level} className="level-container">
                <button
                  className={`level-button ${selectedLevel === level ? 'selected' : ''}`}
                  onClick={() => setSelectedLevel(level)}
                >
                  {level}
                </button>
                {selectedLevel === 'All Levels' && currentRow?.level === level && (
                  <div className="level-indicator">^</div>
                )}
              </div>
            ))}
          </div>

          {currentRow ? (
            <form className="row" aria-live="polite" onSubmit={onSubmit}>
              <span className="before">{(before || '').trim()}&nbsp;</span>
              <span className="inputWrap">
                <input
                  ref={inputRef}
                  className="input"
                  autoCapitalize="off"
                  autoComplete="off"
                  autoCorrect="off"
                  spellCheck={false}
                  value={value}
                  onChange={handleInputChange}
                  pattern="[a-zA-Z-]*"
                  style={{ width: `${inputWidthCh}ch` }}
                  aria-label="Missing preposition"
                />
              </span>
              <span className="after">&nbsp;{(after || '').trim()}</span>
              <button type="submit" className="sr-only">Check</button>
            </form>
          ) : (
            <div>Loading...</div>
          )}

          {currentRow && (
            <div style={{ marginTop: '12px' }}>
              {currentRow.meaning && (
                <div className="key-hint" style={{ fontSize: '14px', textAlign: 'center' }}>
                  <strong>Meaning:</strong> {currentRow.meaning}
                </div>
              )}
              {currentRow.type && (
                <div className="key-hint" style={{ fontSize: '14px', textAlign: 'center', marginTop: '4px' }}>
                  <strong>Preposition type:</strong> {currentRow.type}
                  {preconditionTypes[currentRow.type] && (
                    <span className="tooltip-container">
                      &nbsp;<span dangerouslySetInnerHTML={{ __html: '&#8505;' }} />
                      <span className="tooltip-text key-hint" style={{ fontSize: '14px', textAlign: 'left' }}>
                        {preconditionTypes[currentRow.type]}
                      </span>
                    </span>
                  )}
                </div>
              )}
              <div className="key-hint" style={{ fontSize: '14px', textAlign: 'center', marginTop: '4px' }}>
                <strong>Solved:</strong> <span style={{ color: 'var(--ok)', fontWeight: 'bold' }}>{solvedCount}</span>
              </div>
            </div>
          )}

          {footerContent}

          <div className="action-buttons">
            <div className="button-container">
              <button className="action-button hint" onClick={() => setShowHint(prev => !prev)}>Hint</button>
              <span className="key-hint">&lt;?&gt;</span>
            </div>
            <div className="button-container">
              <button className="action-button submit" onClick={check}>Submit</button>
              <span className="key-hint">&lt;enter&gt;</span>
            </div>
            <div className="button-container">
              <button className="action-button" onClick={pickRandomRow}>Skip</button>
              <span className="key-hint">&lt;esc&gt;</span>
            </div>
          </div>

          {showHint && currentRow && (
            <div className="hint-box">
              <h4>Hint</h4>
              <div><strong>Verb:</strong> {currentRow.verb}</div>
              <div><strong>Preposition:</strong> {answersOf(currentRow).join(' or ')}</div>
            </div>
          )}

          <div className="key-hint" style={{ fontSize: '14px', textAlign: 'center', marginTop: '12px' }}>
            <strong>Last:</strong>{' '}
            {prevAnswerParts ? (
              <>
                {(prevAnswerParts.before || '')}
                {prevAnswerParts.before ? ' ' : ''}
                <strong>{prevAnswerParts.preposition}</strong>
                {prevAnswerParts.after ? ' ' : ''}
                {(prevAnswerParts.after || '')}
              </>
            ) : (
              '---'
            )}
          </div>

          <div className="debug-toggle">
            <input type="checkbox" id="show-debug" checked={showDebug} onChange={e => setShowDebug(e.target.checked)} />
            <label htmlFor="show-debug">Debug Info</label>
          </div>

          {showDebug && currentRow && (
            <div className="debug-box">
              <pre>
                {Object.entries(currentRow).map(([key, value]) => `${key}: ${value}`).join('\n') + '\n\n' + datasetStats}
              </pre>
            </div>
          )}

          <div className="spacer-2"/>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App/>);
  </script>
</body>
</html>
